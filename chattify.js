// Generated by CoffeeScript 1.10.0
(function() {
  var Chattifier, chattifier;

  Chattifier = (function() {
    function Chattifier() {
      this.state = 'init';
      this.ancestorNode = null;
      this.textContent = "";
    }

    Chattifier.prototype.inferAncestorNode = function() {
      var allElements, blockquotes, el, j, k, len, len1, line, maxEl, ref, ref1, score, scores, searchedEl;
      this.state = 'inferAncestorNode';
      blockquotes = document.body.getElementsByTagName("blockquote");
      if (blockquotes.length > 0) {
        this.ancestorNode = blockquotes[0].parentNode;
        return this;
      }
      allElements = Array.prototype.slice.call(document.body.getElementsByTagName("*"));
      searchedEl = [];
      scores = [];
      ref = allElements.reverse();
      for (j = 0, len = ref.length; j < len; j++) {
        el = ref[j];
        searchedEl.push(el);
        score = 0;
        ref1 = el.textContent.split(/\r?\n/);
        for (k = 0, len1 = ref1.length; k < len1; k++) {
          line = ref1[k];
          if (line.match(/^(?:>\s*){2,}/)) {
            score += 1;
          }
        }
        scores.push(score);
      }
      maxEl = Math.max.apply(null, scores);
      if (maxEl > 0) {
        this.ancestorNode = searchedEl[scores.indexOf(maxEl)].parentNode;
      }
      return this;
    };

    Chattifier.prototype.preprocessHTML = function() {
      this.state = 'preprocessHTML';
      if (this.ancestorNode == null) {
        return this;
      }
      this._insertNewLinesIntoDivsAndSpans(this.ancestorNode);
      this._removeBlockquotes(this.ancestorNode);
      this.textContent = this.ancestorNode.textContent;
      return this;
    };

    Chattifier.prototype.cleanIndentation = function() {
      var cleanedLines, j, len, line, lines;
      this.state = 'cleanIndentation';
      lines = this.textContent.split(/\r?\n/);
      cleanedLines = [];
      for (j = 0, len = lines.length; j < len; j++) {
        line = lines[j];
        cleanedLines.push(line.trim().replace(/^(?:>\s*){1,}/, "").trim());
      }
      this.textContent = cleanedLines.join("\n");
      return this;
    };

    Chattifier.prototype.stripFromToBlocks = function() {
      var blockRegex, replacer;
      this.state = 'stripFromToBlocks';
      blockRegex = /From:[\s\S]*?(To|Subject|Date|Cc|Sent):[\s\S]*?(To|Subject|Date|Cc|Sent):[\s\S]*?(To|Subject|Date|Cc|Sent):[\s\S]*?(To|Subject|Date|Cc|Sent):(.*\n){1,2}/g;
      replacer = (function(_this) {
        return function(match, offset, string) {
          var date, from;
          match = match.replace(/\r?\n/g, " ");
          from = (/From:(.*?)(To|Subject|Date|Cc|Sent):/g.exec(match))[1].trim();
          date = (/(Date|Sent):(.*?)(To|Subject|Cc):/g.exec(match))[2].trim();
          return "On " + date + ", " + from + " wrote:\n\n";
        };
      })(this);
      this.textContent = this.textContent.replace(blockRegex, replacer);
      return this;
    };

    Chattifier.prototype.toMarkdown = function() {
      var replacer;
      this.state = 'toMarkdown';
      this.textContent = this.textContent.replace(/(#)/g, "\\$1");
      replacer = (function(_this) {
        return function(match, offset, string) {
          var emailRegex;
          match = match.replace(/\r?\n/g, " ");
          match = match.replace(/([\[\]<>]|mailto:|javascript:;)/g, "");
          emailRegex = /([a-zA-Z0-9_!#$%&'*+\/=?`{|}~^.-]+@[a-zA-Z0-9.-]+)/;
          match = match.replace(emailRegex, "[$1](mailto:$1)");
          return "\n# " + match + "\n";
        };
      })(this);
      this.textContent = this.textContent.replace(/On [\s\S]*?wrote(:|;)/g, replacer);
      return this;
    };

    Chattifier.prototype.toHTML = function() {
      var el, i, j, len, outputTree, parsedTree, ref;
      this.state = 'toHTML';
      parsedTree = markdown.toHTMLTree(markdown.parse(this.textContent));
      outputTree = [parsedTree[0], ["div"]];
      i = 1;
      ref = parsedTree.slice(1);
      for (j = 0, len = ref.length; j < len; j++) {
        el = ref[j];
        if (el[0] === "h1") {
          outputTree.push(["div"]);
          i += 1;
        }
        outputTree[i].push(el);
      }
      this.textContent = markdown.renderJsonML(outputTree);
      return this;
    };

    Chattifier.prototype.postprocessHTML = function() {
      this.state = 'postprocessHTML';
      if (this.ancestorNode == null) {
        return this;
      }
      this.ancestorNode.innerHTML = this.textContent;
      this._colorEncode(this.ancestorNode);
      return this;
    };

    Chattifier.prototype._log = function() {
      var ancestorNode, msg, state, textContent;
      state = "state: " + this.state;
      ancestorNode = "ancestorNode: " + this.ancestorNode.tagName;
      textContent = "textContent: " + this.textContent;
      msg = "{ " + ([state, ancestorNode, textContent].join("\n")) + " }";
      console.log(msg);
      return this;
    };

    Chattifier.prototype._insertNewLinesIntoDivsAndSpans = function(node) {
      var div, divs, j, k, len, len1, results, span, spans;
      divs = node.getElementsByTagName("div");
      for (j = 0, len = divs.length; j < len; j++) {
        div = divs[j];
        div.appendChild(document.createTextNode("\n\n"));
      }
      spans = node.getElementsByTagName("span");
      results = [];
      for (k = 0, len1 = spans.length; k < len1; k++) {
        span = spans[k];
        results.push(span.appendChild(document.createTextNode("\n\n")));
      }
      return results;
    };

    Chattifier.prototype._removeBlockquotes = function(node) {
      var blockquotes, bq, bqHtml, newChild, parent, results;
      blockquotes = node.getElementsByTagName("blockquote");
      results = [];
      while (blockquotes.length > 0) {
        bq = blockquotes[0];
        bqHtml = bq.innerHTML;
        parent = bq.parentNode;
        newChild = document.createElement("p");
        newChild.insertAdjacentHTML('afterbegin', bqHtml);
        parent.insertBefore(newChild, bq);
        parent.removeChild(bq);
        results.push(blockquotes = node.getElementsByTagName("blockquote"));
      }
      return results;
    };

    Chattifier.prototype._colorEncode = function(node) {
      var cl, clStyle, classes, colors, div, divs, i, j, k, len, len1, results, style;
      divs = node.getElementsByTagName("div");
      classes = ['first', 'second'];
      for (i = j = 0, len = divs.length; j < len; i = ++j) {
        div = divs[i];
        div.className = "chattifier " + classes[i % 2];
      }
      style = document.createElement("style");
      style.appendChild(document.createTextNode(""));
      document.head.appendChild(style);
      style.sheet.insertRule("div.chattifier { margin: 2px; display: block; }", 0);
      style.sheet.insertRule("div.chattifier > h1 { margin-bottom: 4px; font-size: 15px; font-family: Georgia,'Times New Roman','Bitstream Charter',Times,serif; }", 0);
      style.sheet.insertRule("div.chattifier > p { margin: 2px; font-size: 15px; font-family: Arial,'Bitstream Vera Sans',Helvetica,Verdana,sans-serif; }", 0);
      colors = ['#FFF', '#F4F4F4'];
      results = [];
      for (i = k = 0, len1 = classes.length; k < len1; i = ++k) {
        cl = classes[i];
        clStyle = "." + cl + " { background-color: " + colors[i] + "; }";
        results.push(style.sheet.insertRule(clStyle, 0));
      }
      return results;
    };

    return Chattifier;

  })();

  chattifier = new Chattifier();

  chattifier.inferAncestorNode().preprocessHTML().cleanIndentation().stripFromToBlocks().toMarkdown().toHTML().postprocessHTML();

}).call(this);
